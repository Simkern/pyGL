#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np
import time
import sys

from scipy import linalg, sparse
from scipy.sparse.linalg import LinearOperator, gmres, cg
from scipy.integrate import solve_ivp
from matplotlib import pyplot as plt

sys.path.append('./git/core/')

from git.core.CGL_parameters import CGL, CGL2
from git.core.diff_mat import FDmat
from git.core.utils import pmat, pvec, p

from git.solvers.arnoldi import arn, arn_inv
from git.solvers.lyapunov import kpik, LR_OSI

from CGLmat import getCGLmatrices

plt.close("all")

eps = 3e-14
n  = 10
I  = np.eye(n)
h  = 1/(n+1)
A = np.diag(-2/h*np.ones((n,)),0) + \
    np.diag(np.ones((n-1,))/h,1) + \
    np.diag(np.ones((n-1,))/h,-1)
#A = np.kron(At,I) + np.kron(I,At)
N = A.shape[0]

# random lhs of rank rk
rk = 5
B = np.random.random_sample((N,rk))

Q = B @ B.T

# random matrix of rank rk = 10
s0    = np.random.random_sample((rk,))
U0, _ = linalg.qr(np.random.random_sample((N, rk)),mode='economic')
S0    = np.diag(s0);
X0    = U0 @ S0 @ U0.T

nQ    = np.linalg.norm(Q)
nA    = np.linalg.norm(A)

# direct solve of A @ X + X @ A.T = -B @ B.T
Xref = linalg.solve_continuous_lyapunov(A, -Q)

# naive Runge-Kutta time integration
def Xdot(t,Xv,A,Q):
    n = A.shape[0]
    X = Xv.reshape((n,n))
    dXdt = A @ X + X @ A.T + Q
    return dXdt.flatten()

# choose integration time
Tend = 10
tspan = (0,Tend)
'''
etime = time.time()
sol = solve_ivp(Xdot,tspan,X0.flatten(),args=(A,Q))
Xrk1 = sol.y[:,-1].reshape(A.shape)
print(time.time() - etime)
etime = time.time()
sol = solve_ivp(Xdot,tspan,X0.flatten(),args=(A,Q), atol=1e-8, rtol=1e-8)
Xrk2 = sol.y[:,-1].reshape(A.shape)
print(time.time() - etime)
etime = time.time()
sol = solve_ivp(Xdot,tspan,X0.flatten(),args=(A,Q), atol=1e-12, rtol=1e-12)
Xrk3 = sol.y[:,-1].reshape(A.shape)
print(time.time() - etime)
'''
etime = time.time()
sol = solve_ivp(Xdot,tspan,X0.flatten(),args=(A,Q), atol=eps, rtol=eps)
Xrk4 = sol.y[:,-1].reshape(A.shape)
print(time.time() - etime)
'''
print(np.linalg.norm(Xrk1 - Xref)/np.linalg.norm(Xref))
print(np.linalg.norm(Xrk2 - Xref)/np.linalg.norm(Xref))
print(np.linalg.norm(Xrk3 - Xref)/np.linalg.norm(Xref))
'''
print(np.linalg.norm(Xrk4 - Xref)/np.linalg.norm(Xref))

rkv = np.arange(8,10,2) #2,10,2)
tauv = np.logspace(-1, -5, 5) # -4, 3)


U,S,res = LR_OSI(A, B, X0, Tend, 1e-2, 'rk', 5, verb=0)
X = U @ S @ U.T
print(np.linalg.norm(Xrk4 - X)/np.linalg.norm(Xrk4))
U,S,res = LR_OSI(A, B, X0, Tend, 1e-3, 'rk', 5, verb=0)
X = U @ S @ U.T
print(np.linalg.norm(Xrk4 - X)/np.linalg.norm(Xrk4))
U,S,res = LR_OSI(A, B, X0, Tend, 1e-4, 'rk', 5, verb=0)
X = U @ S @ U.T
print(np.linalg.norm(Xrk4 - X)/np.linalg.norm(Xrk4))

U,S,res = LR_OSI(A, B, X0, Tend, 1e-2, 'rk', 10, verb=0)
X = U @ S @ U.T
print(np.linalg.norm(Xrk4 - X)/np.linalg.norm(Xrk4))
U,S,res = LR_OSI(A, B, X0, Tend, 1e-3, 'rk', 10, verb=0)
X = U @ S @ U.T
print(np.linalg.norm(Xrk4 - X)/np.linalg.norm(Xrk4))
U,S,res = LR_OSI(A, B, X0, Tend, 1e-4, 'rk', 10, verb=0)
X = U @ S @ U.T
print(np.linalg.norm(Xrk4 - X)/np.linalg.norm(Xrk4))
#p(X - Xref)
#p(X - Xrk)


fig = plt.figure(1)

err = np.empty((len(rkv),len(tauv)))
for i, rk in enumerate(rkv):
    for j, tau in enumerate(tauv):
        
        U,S,res = LR_OSI(A, B, X0, Tend, tau, 'rk', rk, torder=2, verb=1)
        
        X = U @ S @ U.T
        
        err[i,j] = np.linalg.norm(X - Xref, ord='fro')/N
        
    plt.loglog(tauv, err[i,:],label=f'rank {rk}')
plt.title('torder = 2')
plt.legend()

fig = plt.figure(2)

err = np.empty((len(rkv),len(tauv)))
for i, rk in enumerate(rkv):
    for j, tau in enumerate(tauv):
        
        U,S,res = LR_OSI(A, B, X0, Tend, tau, 'rk', rk, torder=1, verb=1)
        
        X = U @ S @ U.T
        
        err[i,j] = np.linalg.norm(X - Xref, ord='fro')/N
        
    plt.loglog(tauv, err[i,:],label=f'rank {rk}')
plt.title('torder = 1')
plt.legend()

plt.show()